Adapterパターンは異なる処理内容、異なる処理数、異なる継承など異なるオブジェクト同士を変換することが可能なクラス設計です。

アダプターインターフェースにはそれぞれ異なる処理が記述されたクラスを統合するための関数を定義。
基本的にアダプターインターフェースに定義するのはmain();

それぞれ異なる処理が記述されたクラスの数分だけアダプターインターフェースを継承したクラスを作成。
作成したそれらのクラスにアダプターインターフェース内で定義したmain()を実装。
実装はそれぞれ異なる処理が記述されたクラスをインスタンス化し、実行したい処理を複数記述。
ここで大事なのが、他のクラスと同じ数の関数や、同じ名前の関数でなければならないといった、
インターフェース特有の制限が存在しないことです。

最後に、実行側のクラスではアダプターインターフェース型の変数にそれぞれのアダプタークラスをインスタンス化し
main関数を呼び出すと、それぞれのアダプタークラスが自動的にそれぞれの異なる処理を行ってくれます。

このAdapterデザインパターンは三層に分かれており、以下のような図になっています。
アダプターインターフェース
↓
アダプタークラス
↑
異なるクラス
ここで重要なのは、アダプターインターフェースはアダプタークラスを参照していますが、
それぞれの異なるクラスには直接干渉していないというところです。

アダプターインターフェースはアダプタークラスに定義されている関数を実行しているだけなので、
その関数内で行われている処理はどのようなものでも互換性などの問題は一切気にしなくていいということになります。

サンプルコードは
HandyLib/Pattern/Adapter/Sample_1.cs
より参照してください。
