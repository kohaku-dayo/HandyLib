Observerパターンは監視する側と監視される側で流れを管理するクラス設計です。

このデザインパターンでは監視する側のことをObserverと言い、監視される側のことをObservableと言います。
監視する側と監視される側でそれぞれ二つインターフェースを作ります。
監視する側には通知が発行された時に実行する処理と関数を記述。監視される側には通知を発行する為の関数を記述。

ここでおや？と、思われた方もいるのではないでしょうか？
監視する側には通知発行時の処理、監視される側には通知発行の処理、逆じゃない？って思いますよね。
流れは以下のような感じです。
ObserverがObservableに通知発行時に呼び出してほしい関数・クラスを登録。
Observableは通知発行時に登録された関数・クラスを全て実行。
Observerが登録した関数・クラスが実行されてイベントハンドラのような流れを実装。

基本的にお互いがお互い定義された関数を使う形です。
なので、監視側には監視される側に使ってほしい関数を用意し、監視される側には監視側に使ってほしい関数を用意することになります。

サンプルコードは HandyLib/Pattern/Observer/Sample_1.cs を参照してください。

Sample_1.csに記述されたIObservableインターフェースに定義されているSubscribe関数の戻り値がIDisposableになっているがわかると思いますが、
これは登録されたクラス・関数をリストから外すためのものです。
任意のタイミングで通知を登録し、任意のタイミングで通知を解除したいこともあるでしょう。
その際に戻り値を用いて消去してください。

ちなみに、Observableクラス内のSubscribe関数は登録、という意味です。
これはユーチューブに例えると簡単に理解することが可能です。
ユーチューブの視聴者は任意のチャンネル(Observable)を登録(Subscribe)することで、チャンネルからの通知(SendNotice)を受け取ることができます。
